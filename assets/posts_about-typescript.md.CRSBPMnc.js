import { _ as _export_sfc, c as createElementBlock, o as openBlock, a as createStaticVNode } from "./app.C38AKkke.js";
const __pageData = JSON.parse('{"title":"小白学 TypeScript 有感","description":"","frontmatter":{"title":"小白学 TypeScript 有感","date":"2022-02-23T00:00:00.000Z","layout":"post","category":"随谈"},"headers":[],"relativePath":"posts/about-typescript.md","filePath":"posts/about-typescript.md","lastUpdated":1768985555000}');
const _sfc_main = { name: "posts/about-typescript.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [..._cache[0] || (_cache[0] = [
    createStaticVNode('<p>说起 TypeScript（以下简称 TS），认识的蛮早，但是因为不喜欢强类型，所以一直排斥使用它。</p><p>但随着越来越多的程序员使用，慢慢的，我也重新审视自己，是不是太井底之蛙了？所以我又重新拾起它，一边阅读一些优秀源码，一边编写小工具来巩固下所学。总算把小工具完成了，我也谈下对比 JS，使用 TS 给我这个小白的感受。</p><p>首先是环境搭建，说实话一开始真不如直接搬运别人的配置，然后倒过来学习。但是我属于那种不弄清楚不罢休，然后过段时间全部忘记的人，这样通常就是在浪费时间。当然最后我还是配置完成了，只是时间浪费的可不是一星半点，所以真心推荐，<strong>新手小白还是先搬运好的配置，稍微熟练之后再尝试自己配置</strong>。</p><p>环境搭建完毕，就要开始写代码了，写代码途中我发现，之前声明了如下的类型：</p><div class="language-ts"><button title="复制代码" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes vitesse-light vitesse-dark" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">export</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> type</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> PropertyKey</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> string</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> |</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> undefined</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> |</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span></span></code></pre></div><p>因为我需要使用这种类型，结果无意间看到 TS 内置了一个叫做 <code>PropertyKey</code> 的类型接口，这就很尴尬了。等于我重复定义了，而且它定义的比我准确多了，有人可能会说你不会去参考看下 <code>lib.dom</code> 库啊，可是关键如果一个新手来做，他知道这个库吗？</p><p>这是写类型遇到的第一个问题：<strong>内置类型/接口不知道如何寻找</strong>。</p><p>当然第一个问题对于我来说还是很好解决的，那么第二个问题就有些复杂，就是我写了一个公共的回调函数，在 TS 中因为不同的接口实现都定义了一套自己的回调类型，结果就是我写的这个方法不停的在转化类型（目前也是这么做的，应该可以优化）。于是我就想到能不能根据谁使用，那么根据使用者来推断类型。答案自然是有的，毕竟我是个后来者，在网络上的列子中我知道了 <code>extends</code> 和 <code>infer</code> 关键字，说真的，至少当时我激动了，有解决方案。可以网络上说的真的太基础，或者官网示例，虽然看了很多，但是说清楚的没几个，至于到现在我对这个 <code>infer</code> 只有特定环境才可以明白如何写，接口就是我依旧没有找到方法去实现我的想法（有一篇<a href="https://my.oschina.net/u/4318809/blog/4293100" target="_blank" rel="noreferrer">文章</a> 我个人觉着讲的还行，因为不是盲目的粘贴复制）。这是我遇到的第二个问题：<strong>如何编写高校的检测类型</strong>。</p><p>遇到的第三个就是关于 eslint，我使用的是官方团队产品 <code>@typescript-eslint/eslint-plugin</code>，可以说提示的还不错，但是每次在写到 JS 中的 <code>object</code> 类型我就是很纠结，因为推荐我使用 <code>Record</code> 类型，我也听话，调整后发现 option 对象不能被 <code>Record</code> 类型兼容，明明定义的 option 类型就是 <code>Record&lt;string, unknown&gt;</code>，为什么还是提示错误呢，后来我换成了 <code>object</code> 类型就可以。目前而言，关于对象的表示依旧不是很清楚怎么写，是写<code>Object</code>，还是<code>object</code>，还是<code>Record</code>，虽然<code>eslint</code>推荐使用<code>Record</code>，但是对于小白来说，真的迷糊了。这只是我举得一个列子，其实就是想说我遇到的第三个问题：<strong>到底应该如何使用合理的类型</strong>。</p><p><s>那么第四个问题，我需要向原始对象 <code>HTMLElement</code> 添加属性，但是 TS 提示不可以，我也能理解，所以为了不污染原始对象，我重新声明了一个新类型：<code>IDomNode</code>，它继承了HTMLElement，写到最后都是没有问题的，但是测试调用时提示，不可传入 <code>HTMLElement</code>，因为 <code>HTMLElement</code> 没有 <code>IDomNode</code> 上的一些属性，关键这个 <code>IDomNode</code> 又不是一上来就有，难道需要自己再写个方法将每一个 <code>HTMLElement</code> 初始化成 <code>IDomNode</code>，最后我先使用了折中办法，将所有的<code>IDomNode</code> 类的属性变成可选，这就导致只要是使用到 <code>IDomNode</code> 的属性需要先判空，虽然可以肯定他们存在，但是 TS 不信他们是存在的。所以我又写了一堆方法判空，感觉显得很多余。</s> 果然使用方式不对，应该是拿到 <code>HTMLElement</code>，内部转化成 <code>IDomNode</code> 类型即可。</p><p>网络上很多做对比的文章，当然都不及自己尝试写写 <strong>Type</strong>Script，它正如字面意思，就是为了检查类型的，可能很严格，但是真的很有用。不过就目前而言，以我的水平，TS 更多像枷锁一样，可能是我习惯 JS 太久了，还有很长的路要走。</p>', 11)
  ])]);
}
const aboutTypescript = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  aboutTypescript as default
};
